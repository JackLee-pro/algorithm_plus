# 链表
## 什么是链表
数组和链表基本上是Java中被提及最多的数据结构了。那么什么是链表呢？

简单来说，链表，就是一个节点指向下一个下一个节点，下一个节点又指向它的下一个节点，这个其实有点像黄河大合唱的时候（加入黄河大合唱只排第一排...），你需要记住你是排在什么位置的，那你怎么记呢？你只需要需要记住你旁边的两个人就ok了，像这样：
同学A <--> 同学B <--> 你 <--> 同学C，这个其实就是双链表，你需要记住排在你前左边（pre）一个同学B，和右边（next）一个同学C,然后你的位置就确定了。

除了双链表，如果同学们排队并且围成一个圈，那就变成了双向循环链表了。如果每个同学都只能记住下一个同学，那就是单项链表了。

在从技术的角度总结一下，
* 单项链表，持有对下一个节点的引用next
* 双向链表，持有前一个（pre）和后一个（next）的引用
* 双向循环链表，头尾相连的双向链表
## 为什么要使用链表？链表有什么好处和坏处
链表不像数组对空间有连续性的需求，所以如果需要对某个元素进行增删操作，那么只需要维护链表中指针的指向就Ok了；而数组呢，为了保持空间的连续性，和数组的内存寻址，就必须要对数组中的元素进行搬移工作。当然，如果在尾部新增或者删除一个元素，那需要的时间复杂度确实是O(1)级别的，但按照时间复杂度的分析来看，按最差的情况分析，在数组头部插入一个元素，或者删除头部元素，那时间复杂度就是O(n)了。

所以我们经常说，链表适合增删操作，而数组适合查找（可以根据寻址公式以O(1)的时间复杂度找到指定索引的元素，又叫随机访问）。
那什么时候需要使用链表呢？最常用的场景就是LruCache(最近最少使用算法)，有新元素添加时，则添加到尾部（时间复杂度O（1））；如果达到内存设置的阈值，就把头部的相关元素和内存释放掉（时间复杂度O(1)）
## 如何实现一个链表
链表的实现基本上很简单了，平时在做算法题的时候算法也会给出一个简单的单链表的实现，其实只需要定义当前节点，并持有下一个节点的引用就OK了。
代码如下
```
public class ListNode {
    int val;
    ListNode(int x) {
      val = x;
      next = null;
    }
}
```
如果是双向链表，则ListNode再持有一个pre的ListNode指针就Ok了。

如果想要深入了解请参考[算法专栏](http://gk.link/a/104fH)中链表的相关文章
